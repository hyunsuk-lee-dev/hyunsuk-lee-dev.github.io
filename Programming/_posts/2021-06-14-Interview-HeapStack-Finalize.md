---
layout: post
title: '면접 질문 정리 3 - 힙과 스택 / Dispose와 Finalize'
tags: [CS]
image : /assets/img/post/2021-06-14-Interview-HeapStack-Finalize/main.jpg
description: >
  메모리 공간의 분류인 힙과 스택의 차이점, 그리고 Dispose와 Finalize의 차이점에 대해서 알아보도록 합시다. 
---

* toc
{:toc .large-only}
이번에 정리할 내용은 메모리 관리에 관련된 내용들입니다. 힙과 스택의 차이점과 Dispose와 Finalize의 차이점에 대해 묻는 질문이었습니다. 사실 두 질문은 같이 나온 질문은 아니고 달리 나왔던 질문인데, 메모리라는 같은 맥락에서 설명할 수 있을 것 같아서 한 포스트로 묶어봤습니다. 

## 힙과 스택

힙과 스택에 대한 내용은 아주 기초적인 CS 질문 중에 하나입니다. 이를 이야기하려면 먼저 메모리 구조에 대해 이야기할 필요가 있습니다. 프로그램이 실행되기 위해서는 먼저 프로그램을 구성하는 코드들이 메모리에 올라가야(로드, Load) 합니다. 또한, 프로그램 중에는 변수에 대한 데이터를 메모리에 저장해야 하기도 합니다. 

따라서 메모리는 크게 4가지 영역으로 분류할 수 있습니다.

1. 코드 영역

2. 데이터 영역

3. 힙 영역

4. 스택 영역

![메모리 구조](/assets/img/post/2021-06-14-Interview-HeapStack-Finalize/memory.png){:.center}

메모리의 4가지 영역
{:.figcaption}

이 중 이번에 살펴볼 부분은 [3. 힙]과 [4. 스택] 영역에 대한 내용입니다. [1.코드]와 [2. 데이터] 영역은 프로그램이 실행되면 바로 영역의 크기가 정해지고 변하지 않는데에 반해 힙과 스택은 프로그램이 실행되면서 실시간으로 그 크기가 변하게 됩니다.

### 스택 영역

스택 영역은 함수의 호출과 관계되는 변수(매개변수 및 지역변수)들이 저장되는 공간입니다. 함수의 호출과 동시에 할당이 되고, 함수가 끝나면 해제됩니다. 

프로그램의 실행에 따라 자동으로 할당되고, 자동으로 해제되기 때문에 개발자가 직접 관리하지는 않습니다. 반대로, 함수가 끝나면 해제되기 때문에 저장되어 있는 공간을 전역적으로 접근할 수 없다는 단점이기도 합니다. 

해당 영역의 이름이 말해주는 것처럼 스택의 구조를 가지고 있습니다. 스택 자료구조처럼 LIFO(Last-In First-Out)의 특성을 가지고 있습니다. 이는 스택 영역이 함수의 호출과 함께 사용된다는 점을 생각해보면 아주 당연한 것입니다.

```c#
public void Main()
{
    // (1)
    FirstFunction(1);
    // (4)
}

private void FirstFunction(int variableA)
{
    int variableB = 1;
    // (2)
    SecondFunction(3);
    // (3)
}

private void SecondFunction(int variableC)
{
    int variableD = 3;
}
```

위와 같은 예시 코드가 동작할 때 스택은 아래와 같은 모습으로 변합니다. 

(1) FirstFunction이 실행되면서, 스택 영역에 `variableA`와 `variableB`가 할당이 됩니다.

(2) SecondFunction이 실행되면서, 스택 영역에는 추가로 `variableC`와 `variableD`가 할당이 됩니다.

(3) SecondFunction이 끝나면서, 스택 영역에  `variableC`와 `variableD`가 해제 됩니다. (LIFO 후입선출)

(4) FirstFunction이 끝나면서, 스택 영역에 `variableA`와 `variableB`가 해제 됩니다.

이처럼 함수의 시작과 끝에 따라서 스택 영역이 사용되기 때문에 LIFO와 같이 작동하게 됩니다. 

|    (1)    |    (2)    |    (3)    | (4)  |
| :-------: | :-------: | :-------: | :--: |
|           | variableD |           |      |
|           | variableC |           |      |
| variableB | variableB | variableB |      |
| variableA | variableA | variableA |      |

또한, 스택이라는 구조의 특성에 따라 그림이 보여주는 것처럼 높은 주소부터 시작해서 낮은 주소 순으로 할당이 됩니다. 

### 힙 영역

힙 영역은 스택 영역과는 다르게 개발자가 직접 할당과 해제를 해주어야 하는 관리 가능한 영역입니다. 관리가 가능하다는 것은, 곧 반드시 개발자가 관리해야 한다는 것을 의미하기도 합니다.(GC의 동작도 개발자가 관리하는 동작으로 간주합니다.)

우리가 동적 할당이라고 부르는 일들이 바로 이 힙 영역에 메모리를 할당해주는 것을 의미합니다. C에서는 `int* pointer = (int *)malloc(size)`를 사용했고, c++에서는 `int* pointer = new int;`를 사용한 것들이 바로 힙 영역에 메모리를 할당해주는 것이었습니다. 

보통 새로운 클래스를 생성할 때, `Contructor`를 부를 때, 해당 클래스의 인스턴스 데이터를 힙 영역에 할당해주게 됩니다.

[이전 글](https://leehs27.github.io/programming/2021-06-10-Interview-Integer/){:target="_blank"}에서 `int`와 `Integer`를 비교하면서 래퍼 클래스에 대한 설명을 한 적이 있는데, 래퍼 클래스의 특징 중 하나가 바로 이 힙 영역을 사용한다는 점입니다. 

### 차이 정리

|    분류     |      스택      |          힙          |
| :---------: | :------------: | :------------------: |
| 메모리 관리 | 하지 않아도 됨 |       해야 함        |
|    접근     |  접근 불가능   | 전역적으로 접근 가능 |
|  접근 속도  |   매우 빠름    |   상대적으로 느림    |
|  크기 결정  |  컴파일 타임   |       런 타임        |

### 힙과 스택의 공유 영역

사실 스택 영역과 힙 영역은 메모리의 같은 주소를 공동으로 사용합니다. 그 말인즉슨, 둘 중 어느 한 영역이 과도하게 커지면, 다른 영역은 메모리를 할당할 수 없음을 의미합니다. 그러므로 잘 사용해야 합니다. 힙 영역에서는 적절한 할당과 해제를 통해서 낭비되는 주소가 생기지 않도록 해야하고, 스택 영역은 불필요한 지역변수, 매개변수 사용을 지양하고, 비정상적으로 반복적인 함수의 호출(특히, Recursive)을 방지해야합니다.

## Dispose와 Finalize

Dispose는 영어로 '처분하다', '폐기하다'와 같은 의미입니다. Finalize는 '결말을 짓다', '마무리하다'라는 뜻입니다. 두 이름의 뜻을 생각해보면, 말 그대로 이미 모든 용도가 끝나서 이제 더 이상 사용하지 않는 리소스들을 해제해서 메모리의 공간을 확보하는 일을 지칭하는 것을 알 수 있습니다. 

둘의 차이는 명시적인 방법(Dispose)인지, 암시적인 방법(Finalize)인지에 대한 차이입니다. 

C#이나 Java와 같은 최신 언어들을 사용하면 메모리 리소스를 개별적으로 해제하지 않아도 GC에 의해 사용하지 않는 메모리는 자동으로 해제됩니다. 이 때 불리는 방법이 암시적인 방법인 Finalize입니다. 반면, GC에 의해서가 아니라 개발자에 의해 직접 메모리를 해제하기도 합니다. 그럴  때 사용되는 방법이 명시적 방법인 Dispose인 것입니다. C#에서는 [`Disposable`이라는 리소스 해제 인터페이스](https://docs.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=net-5.0){:target="_blank"}를 제공하고 있습니다.

한마디로, 둘의 차이는 GC에 의해 자동으로 불려지는냐, 또는 개발자가 직접 메모리 해제 함수를 부르느냐에 대한 차이라고 말할 수 있겠습니다.

유의해야할 점은 Dispose를 한다고 해서, 바로 메모리가 해제되는 것이 아니라는 점입니다. Dispose를 부르면, GC에게 이 메모리는 더 이상 쓰지 않는 것이라고 알려주는 것이고, 실제로 언제인지 알 수 없지만 특정 시점에 GC가 동작하면서 메모리를 반환하게 됩니다. 그래서 마이크로소프트에서는 Dispose를 사용할 때, GC가 바로 동작할 수 있도록 `GC.SuppressFinalize(this)`를 같이 쓰는 것을 권장하고 있습니다. [마이크로소프트 Dispose 패턴 구현 매뉴얼 참고](https://docs.microsoft.com/ko-kr/dotnet/standard/garbage-collection/implementing-dispose){:target="_blank"}
{:.note}

---